// Copyright (c) 2018 Arista Networks, Inc.  All rights reserved.
// Arista Networks, Inc. Confidential and Proprietary.

/* In meteorology, a common statistical tool is the median of a given set of 
 * measurements. (You can find a definition of the median in the Notes section.)
 *
 * You are writing software for a device that measures temperature once a second. 
 * The device has a small digital display. At any moment, the display has to show 
 * the median of temperatures measured in the last K seconds.
 *
 * Before you upload your software into the device, you would like to test it on 
 * a computer.
 *
 * Instead of measuring temperatures, we will use a random number generator (RNG) 
 * to generate fake temperatures. Given three ints seed, mul and add, we define a 
 * sequence of temperatures:
 *
 *      t0 = seed
 *      tk+1 = (tk * mul + add) mod 65536
 * 
 * In addition to the parameters of the RNG, you will be given two ints N and K.
 *
 * Consider the sequence containing the first N temperatures generated by the RNG 
 * (i.e., values t0 to tN-1). This sequence has N-K+1 contiguous subsequences of 
 * length K. For each such subsequence compute its minimum.
 *
 * Your method will be given the numbers seed, mul, add, N, and K. Compute all 
 * the minimum as described above, and return a long containing their sum.
 */

#include <iostream>
#include <vector>
#include <math.h>
#include <map>
#include <bitset>
#include <stack>

typedef std::vector<std::vector<int>> intArrayStore;
typedef std::vector<int> intArray;

class FloatingMedian {
 private:
   class cartesianTree {
    public:
      int treeNumber; // K < 16
      const std::vector<int> &v;
      int start;
      int end;

      cartesianTree( const std::vector<int> &v_, int start_, int end_ ) : 
         v( v_ ), treeNumber(0), start(start_), end( end_ ) {
         // We use a stack to pass through from beginning to end
         // 1) Push the number onto the stack and append '1' bit to treeNumber 
         // 2) Pop until we find a number on the stack less than current number or empty.
         //    For each pop, we append '0' to treeNumber.
         //std::cout << "CartesianTree Constructor(" << start << "," 
         //          << end-1 << ")" << std::endl;
         std::stack<int> tr;
         for( auto it = v.begin() + start; it != v.begin() + end; it++ ) {
            //std::cout << *it << " ";
            while( !tr.empty() ) {
               auto k = tr.top();
               if( k > *it ) {
                  //std::cout << "pop ";
                  tr.pop();
                  treeNumber = treeNumber << 1;
               } else {
                  break;
               }
            }
            //std::cout << "push ";
            tr.push(*it);
            treeNumber = (treeNumber << 1) + 1;
            //std::cout << std::bitset<20>( treeNumber ) << std::endl;
         }

         while( !tr.empty() ) {
            tr.pop();
            //std::cout << "pop ";
            treeNumber = treeNumber << 1;
            //std::cout << std::bitset<20>( treeNumber ) << std::endl;
         }
         //std::cout << std::endl;
      }
   
      void computeNaiveRMQ( intArrayStore &rmq ) {
         // Since all vectors(start, end) with same treeNumber are the same
         // We just compute the naiveRMQ which takes O(N^2, 1)
         for( int i = 0; i < end - start; i++ ) {
            rmq.push_back(intArray());
            rmq[i].push_back(i + start); 
         }

         for( int i = 0; i < end - start; i++ ) {
            for( int j = 1; j + i < end - start; j++ ) {
               int index = v[ rmq[i][j-1] ] < v[ rmq[j+i][0] ] ? 
                  rmq[i][j-1] : rmq[j+i][0];
               rmq[i].push_back( index );
            }
         }
         
         //for( int i = 0; i < end - start; i ++ ) {
         //   for( int j = 0; j < rmq[i].size(); j++ ) {
         //      std::cout << "rmq[" << i << "][" << j << "]=" << rmq[i][j] << " ";
         //   }
         //   std::cout << std::endl;
         //}
      }
      
      void dfs(int root, std::vector<int> &p,
            std::vector<int> &l, std::vector<int> &s, int sectionSize) {
         
         if( l[root] == 0 ) s[root] = root ;
         else if( l[root] >= sectionSize && l[root] % sectionSize == 0 ) s[root] = p[root];
         else s[root] = s[p[root]];
         
         for( int i = 0; i < p.size(); i++ ) {
            // children have parent pointed to current root index
            if( p[i] == root ) dfs( i, p, l, s, sectionSize );
         }
      }

      void computeLCA( intArrayStore &lca ) {
         // 1) We use a stack to construct the cartessian tree from the block
         // 2) For each element in the block we save the index of its parent node 
         // 3) We construct a level array indicating each node's level in the tree
         // 4) We build a sectional view of the tree in O(N) time
         lca.push_back(intArray(end-start, -1)); // parent array
         std::stack<int> st;
         for( int i = 0; i < end - start; i++ ) {
            int lastPop = -1;
            while( !st.empty() ) {
               int k = st.top();
               if( v[k + start] > v[i + start] ) {
                  lastPop = k;
                  st.pop();
               } else {
                  break;
               }
            }

            if( !st.empty() ) lca[0][i] = st.top(); 
            if( lastPop != -1 ) lca[0][lastPop] = i;

            st.push( i ); 
         }

         //std::cout << "parent: ";
         //for( auto &&i : lca[0] ) {
         //   std::cout << i << " ";
         //}
         //std::cout << std::endl;

         lca.push_back(intArray(end-start, -1)); // level array
         for( int j = 0; j < lca[0].size(); j++ ) {
            int lvl = 0;
            int index = j;
            if( lca[1][j] == -1 ) {
               while( lca[0][index] != -1 ) {
                  index = lca[0][index];
                  lvl++;
               }
               lca[1][j] = lvl;
            }
         }

         //std::cout << "level: ";
         //for( auto &&i : lca[1] ){
         //   std::cout << i << " ";
         //}
         //std::cout << std::endl;

         lca.push_back(intArray(end-start, -1)); // section array
         int sectionSize = sqrt( end-start );
         int root;
         for( int j = 0; j < lca[0].size(); j++ ) {
            if( lca[0][j] == -1 ) {
               root = j;
               break;
            }
         }
         dfs(root, lca[0], lca[1], lca[2], sectionSize );
         
         //std::cout << "section: ";
         //for( auto &&i : lca[2] ){
         //   std::cout << i << " ";
         //}
         //std::cout << std::endl;
         
      }

      int queryRMQ( intArrayStore &rmq, int from, int to ) {
         if( from < 0 || to > end - start ) return -1;
         return rmq[from][to-from];
      }


      int queryLCA( intArrayStore &lca, int from, int to ) {
         // We find the lowest common ancestor between element from and to.
         // 1) We use the section view of the tree to get from and to to the same
         //    level
         // 2) We move them up until their parents are the same
         while( lca[2][from] != lca[2][to] ) {
            if( lca[1][from] < lca[1][to] ) {
               to = lca[2][to];
            } else {
               from = lca[2][from];
            }
         }

         while( to != from ) {
            if( lca[1][from] < lca[1][to] ) {
               to = lca[0][to];
            } else {
               from = lca[0][from];
            }
         }

         // We return the absolute index rather than the relative index of block
         return to + start;
      }

   };

   std::map<int, cartesianTree*> blockToTreeNumber;
   std::map<int, std::vector<std::vector<int>>> blockRMQ;
   std::map<int, std::vector<std::vector<int>>> blockLCA;
   std::vector<int> minOfEachBlockRMQ;
   std::vector<int> minOfEachBlockLCA;
   std::vector<std::vector<int>> stRMQ;
   std::vector<std::vector<int>> stLCA;
     
   friend std::ostream& operator<<( std::ostream& out, const FloatingMedian::cartesianTree& );

 public:
   // We will use O(N,1) range minimum query with block size K. Each block will
   // have a minimum value which will be preprocessed by O(N/KlogN/K, 1) sparse 
   // table while each block will have an associated cartesian tree (O(k) to build)
   // with O(K^2, 1) naive solution on the block index. 
   //
   // Just for fun, we will also build O(KlogK, logK) lowest common ancestor 
   // for querying the minimum over a block. 
   void preprocess( std::vector<int> &s, int K ) {
      // build cartesian tree in blocks of K
      for( int i = 0; i < 1+(s.size()-1)/K; i++ ) {
         //std::cout << "Building cartesian tree for block " << i << " [" << i*K << "," 
         //          << (i+1)*K-1 << "]" << std::endl;
         cartesianTree *c = new cartesianTree( s, i * K, (i+1) * K );   
         //std::cout << *c << std::endl;

         //std::cout << "Insert into blockToTreeNumber block " << i << " " 
         //          << std::bitset<20>( c->treeNumber ) << std::endl;
         blockToTreeNumber.insert( 
               std::map<int, cartesianTree*>::value_type(i, c) );

         if( blockRMQ.find( c->treeNumber ) == blockRMQ.end() ) {
            //std::cout << "BlockRMQ does not contain cartesian tree " 
            //          << std::bitset<20>( c->treeNumber ) << std::endl; 
            blockRMQ.insert( 
                  std::map<int, std::vector<std::vector<int>>>::value_type( 
                     c->treeNumber,  
                     std::vector<std::vector<int>>() ) 
                  );
            //std::cout << "Compute Naive RMQ for cartesian tree " 
            //          << std::bitset<20>( c->treeNumber) << std::endl;
            c->computeNaiveRMQ( blockRMQ[ c->treeNumber ] );
         }

         if( blockLCA.find( c->treeNumber ) == blockLCA.end() ) {
           //std::cout << "BlockLCA does not contain cartesian tree " 
           //           << std::bitset<20>( c->treeNumber ) << std::endl; 
            blockLCA.insert( 
                  std::map<int, std::vector<std::vector<int>>>::value_type( 
                     c->treeNumber,  
                     std::vector<std::vector<int>>() ) 
                  );
           // std::cout << "Compute LCA array " << std::bitset<20>( c->treeNumber ) << std::endl;
            c->computeLCA( blockLCA[ c->treeNumber ] );
         }
         
         //std::cout << "Query " << std::bitset<20>( c->treeNumber ) << " for min index" 
         //          << std::endl;
         
         int index = c->queryRMQ( blockRMQ[ c->treeNumber ], 0, K-1 );
         //std::cout << "Push min index " << index << " of block onto minOfEachBlockRMQ" 
         //          << std::endl;
         minOfEachBlockRMQ.push_back( index );

         index = c->queryLCA( blockLCA[ c->treeNumber ], 0, K-1 );
         //std::cout << "Push min index " << index << " of block onto minOfEachBlockLCA" 
         //          << std::endl;
         minOfEachBlockLCA.push_back( index );
      }

      // build stRMQ from minOfEachBlockRMQ
      for( int i = 0; i < minOfEachBlockRMQ.size(); i++ ) {
         stRMQ.push_back(std::vector<int>());
         stRMQ[i].push_back(minOfEachBlockRMQ[i]);
      }

      for( int i = 0; 1 << (i+1) < minOfEachBlockRMQ.size(); i++ ) {
         for( int j = 0; j + (1 << (i+1)) - 1 < minOfEachBlockRMQ.size(); j++ ) {
            //std::cout << "--------" << std::endl;
            //std::cout << "stRMQ[" << j << "][" << i << "]=" << stRMQ[j][i] << std::endl;
            //std::cout << "stRMQ[" << j + ( 1 << i ) << "][" << i << "]=" 
            //          << stRMQ[j+(1<<i)][i] << std::endl;
            //std::cout << "stRMQ comparing " << s[ stRMQ[j][i] ] << " " 
            //          << s[ stRMQ[j+(1<<i)][i] ] << std::endl;
            int index = s[ stRMQ[j][i] ] < s[ stRMQ[j+(1<<i)][i] ] ? 
                              stRMQ[j][i] : stRMQ[j+(1<<i)][i];
            //std::cout << "stRMQ[" << j << "][" << i+1 << "] index " << index << std::endl;
            //stRMQ[j].push_back(index);
         }
      }
      
      // build stRMQ from minOfEachBlockLCA
      for( int i = 0; i < minOfEachBlockLCA.size(); i++ ) {
         stLCA.push_back(std::vector<int>());
         stLCA[i].push_back(minOfEachBlockLCA[i]);
      }
      for( int i = 0; 1 << (i+1) < minOfEachBlockLCA.size(); i++ ) {
         for( int j = 0; j + (1 << (i+1)) - 1 < minOfEachBlockLCA.size(); j++ ) {
            //std::cout << "--------" << std::endl;
            //std::cout << "stLCA[" << j << "][" << i << "]=" << stLCA[j][i] << std::endl;
            //std::cout << "stLCA[" << j + ( 1 << i ) << "][" << i << "]=" 
            //          << stRMQ[j+(1<<i)][i] << std::endl;
            //std::cout << "stLCA comparing " << s[ stLCA[j][i] ] << " " 
            //          << s[ stRMQ[j+(1<<i)][i] ] << std::endl;
            int index = s[ stLCA[j][i] ] < s[ stLCA[j+(1<<i)][i] ] ? 
                              stLCA[j][i] : stLCA[j+(1<<i)][i];
            //std::cout << "stLCA[" << j << "][" << i+1 << "] index " << index << std::endl;
            //stLCA[j].push_back(index);
         }
      }
   }

   int query( std::vector<int> &v, int i, int j, int blockSize, bool LCA ) {
      // 1) Find block number of i and j. 
      // 2) Use stRMQ to find the minimum of block(i)+1 and block(j)-1
      // 3) Find cartesian tree number of block(i) and block(j)
      // 4) Find the NaiveRMQ or LCA for the block to find minimum of [i, end of block(i)]
      //    and [start of block(j) to j]
      // 5) Find the minimum of the three minimums (these are indexes into minOfEachBlock
      //    and the cartesian blocks)
      int block_i = i / blockSize;
      int blockIndex_i = i % blockSize;
      int block_j = j / blockSize;
      int blockIndex_j = j % blockSize;
  
      //std::cout << "\tIndex " << i << " in block " << block_i << " blockIndex " 
      //          << blockIndex_i << std::endl;
      //std::cout << "\tIndex " << j << " in block " << block_j << " blockIndex " 
      //          << blockIndex_j << std::endl;

      // I guess the way we do blocking, this would never be called  ¯\_(ツ)_/¯. 
      int minBlockIndex = -1;
      if( block_i + 1 <= block_j-1 ) {
         int k = log2( block_j - block_i + 1 ); 
         if (LCA) { 
            minBlockIndex = v[ stLCA[block_i+1][k] ] < v[ stLCA[block_j - (2 << k) + 1][k] ] ?
               stLCA[block_i+1][k] : stLCA[block_j - (2 << k) + 1][k];
         }
         else {
            minBlockIndex = v[ stRMQ[block_i+1][k] ] < v[ stRMQ[block_j - (2 << k) + 1][k] ] ?
               stRMQ[block_i+1][k] : stRMQ[block_j - (2 << k) + 1][k];
         }
      }

      auto c = blockToTreeNumber[ block_i ];
      int minBlock_i;
      if ( LCA ) {
         minBlock_i = c->queryLCA( blockLCA[ c->treeNumber ], blockIndex_i, blockSize-1 ); 
      } else {
         minBlock_i = c->queryRMQ( blockRMQ[ c->treeNumber ], blockIndex_i, blockSize-1 ); 
      }
      //std::cout << "\tBlock " << block_i << " " << *c << " min=" << minBlock_i << std::endl;
      
      c = blockToTreeNumber[ block_j ];
      int minBlock_j;
      if( LCA ) {
         minBlock_j = c->queryLCA( blockLCA[ c->treeNumber ], 0, blockIndex_j );
      } else {
         minBlock_j = c->queryRMQ( blockRMQ[ c->treeNumber ], 0, blockIndex_j );
      }
      //std::cout << "\tBlock " << block_i << " " << *c << " min=" << minBlock_j << std::endl;
         
      int minVal = 0;
      if( v[ minBlock_i ] < v[ minBlock_j ] ){
         minVal = v[ minBlock_i ];
      } else {
         minVal = v[ minBlock_j ];
      }

      if( minBlockIndex != -1 && v[ minBlockIndex ] < minVal ) {
         return minBlockIndex;
      }
      return minVal;
   }
   
   long sumOfMin( std::vector<int> &seq, int K ) {
      // Print the sequence
      std::cout << "Preprocess: ";
      for( int i = 0; i < seq.size(); i++ ) {
         std::cout << seq[i] << " ";
         if( (i + 1) % K == 0 && i != 0 ) std::cout << " | ";
      }
      std::cout << std::endl;
      preprocess( seq, K );
      
      // Finding the minimum involves simply querying the preprocessed RMQ array 
      // with the desired range.
      
      long sumLCA = 0;
      for( int i = 0; i <= seq.size() - K; i++ ) {
         long min = query( seq, i, i+K-1, K, true );
         //std::cout << "Querying min[" << i << "," << i+K-1 << "]=" << min << std::endl;
         sumLCA += min; 
      }
      long sumRMQ = 0;
      for( int i = 0; i <= seq.size() - K; i++ ) {
         long min = query( seq, i, i+K-1, K, false );
        // std::cout << "Querying min[" << i << "," << i+K-1 << "]=" << min << std::endl;
         sumRMQ += min; 
      }


      return sumLCA == sumRMQ ? sumLCA : -1;
   }
};

std::ostream& operator<<( std::ostream& out, const FloatingMedian::cartesianTree& c ) {
   return out << std::bitset<20>( c.treeNumber ) << " -> [" << c.start << "," << c.end-1 << "]";
}

int main( int argc, char** argv ) {
   int seed = 10;
   int mul = 1.1;
   int add = 3;
   int N = 50;
   int K = 10;
   std::vector<int> rngSequence;

   srand(seed);   
   
   rngSequence.push_back(rand() % 35);

   for( int i=1; i < N; i++ ) {
      int add = rand() % 100 - 50;
      int val = ( rngSequence[i-1] * mul + add ) % 65536;
      rngSequence.push_back(val);
   }

   FloatingMedian m;
   std::cout << "Sum of min=" << m.sumOfMin( rngSequence, K ) << std::endl;

   return 0;
}
